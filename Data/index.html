<p>Database Design and Implementation</p>

<h1>1 Introduction:  Why a Database System?</h1>

<h1>2 Data Definition</h1>

<h4>Definitions</h4>

<ul>
<li><p>Relational Database</p>

<ul>
<li>The data in a relational database is organized into tables.  Each table
contains zero or more records and one or more fields.</li>
</ul></li>
<li><p>type</p>

<ul>
<li>each field has a specified type. Some examples are: numbers, strings,
date/time </li>
</ul></li>
<li><p>Constraint</p>

<ul>
<li><p>Restricts the allowable records in a table.  The database system ensures
that the constraints are satisfied by refusing to execute any update
request that would violate them.</p>

<p>Some types are:</p>

<ul>
<li>Integrity
<ul>
<li>Specifies business rules for an organization. I.e. a professor
teaches at most two sections per year</li>
</ul></li>
<li>Null Value</li>
<li>Key
<ul>
<li>No two records can have the same values for the key</li>
<li>A primary key can never be null</li>
</ul></li>
<li>Referential Integrity
<ul>
<li>requires each non-null foreign key value to be the key value of
some record</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Null Value</p>

<ul>
<li>a placeholder for a missing or unknown value.  </li>
</ul></li>
<li><p>Key</p>

<ul>
<li>A minimal set of fields that can be used to identify a record.  </li>
</ul></li>
<li><p>foreign key</p>

<ul>
<li>a set of fields from one table that corresponds to the primary key of
another table. </li>
</ul></li>
<li><p>SQL 'create table' command</p>

<ul>
<li>specifies the name of the table, the name and type of the fields and any
constraints
In addition:
<ul>
<li>An integrity constraint on individual records is specified by means of
the <span class='italics' >check</span> keyword, followed by the constraint expression.</li>
<li>A null value constraint</li>
</ul></li>
</ul></li>
</ul>

<h1>3 Data Design</h1>

<h4>Definitions</h4>

<ul>
<li><p>Class Diagram</p>

<ul>
<li>describes the entities that the database should hold and how they should
relate to each other.  It has three constructs:
<ul>
<li>class: a type of entity</li>
<li>relationship: a meaningful correspondence between the entities of two
or more classes</li>
<li>attribute: denotes a value that describes an entity.</li>
</ul></li>
</ul></li>
<li><p>Cardinality</p>

<ul>
<li>annotations indicate, for a given entity, how many other entities can be
related to it. I.e. 1 - *</li>
</ul></li>
<li><p>Multi-way relationship</p>

<ul>
<li>involves three or more classes</li>
</ul></li>
<li><p>Reification</p>

<ul>
<li>the process of turning a relationship into a class</li>
</ul></li>
<li><p>Redundant</p>

<ul>
<li>if removing a relationship does not change the information content of the
class diagram.</li>
</ul></li>
<li><p>functional dependency (FD)</p>

<ul>
<li>A1A2..AN --> B asserts that two records having the same values for the Ai
fields must also have the same value for the field B.</li>
</ul></li>
<li><p>key-based FD</p>

<ul>
<li>the fields on the LHS form a key</li>
<li>a table that has a non-key-based FD contains redundancy</li>
</ul></li>
<li><p>Boyce-Codd Normal Form (BCNF)</p>

<ul>
<li>a relational schema is in this form if all full FD's are key-based</li>
</ul></li>
<li><p>Third Normal Form (3NF)</p>

<ul>
<li>a relational schema is in this form if the RHS field for all non-key-based
FD's belongs to some key</li>
</ul></li>
</ul>

<p>Note a foreign key corresponds to a weak-strong relationship</p>

<h3>3.3.2 Transforming a Relational Schema</h3>

<ol>
<li>Create a class for each table in the schema</li>
<li>If table T1 contains a foreign key of table T2, then create a relationship
between classes T1 and T2.  The annotation next to T2 will be 1.  The
annotation next to T1 will be 0..1 if the foreign key is also a key;
otherwise, the annotation will be *</li>
<li>Add attributes to each class.  The attributes should include all fields of
its table, except for the foreign keys and any artificial key fields. </li>
</ol>

<h3>3.3.3 Transforming a Class Diagram</h3>

<ol>
<li>Create a table for each class, whose fields are the attributes of that class.</li>
<li>Choose a primary key for each table.  If there is no natural key, then add a
field to the table to serve as an artificial key</li>
<li>For each weak-strong relationship, add a foreign key field to its weak-side
table to correspond to the key of the strong-side table.</li>
</ol>

<h2>3.2 The Design Process</h2>

<ol>
<li>Create a requirements specification</li>
<li>Create a preliminary class diagram from the nouns and verbs of the
specification</li>
<li>Check for inadequate relationships in the diagram</li>
<li>Remove redundant relationships from the diagram.</li>
<li>Revise weak-weak and strong-strong relationships</li>
<li>Identify the attributes for each class.</li>
</ol>

<h1>3 The Relational Model (OLD BOOK)</h1>

<h4>Definitions</h4>

<h2>Background</h2>

<p>1969 IBM E.F. Codd 
1979 - Relational model </p>

<h3>Three Components</h3>

<blockquote>
  <ol>
<li><p>The structural components</p>

<ul>
<li>The structural component: This component defines how information is
structured, or represented. Specifically, all information is represented
as relations, which are composed of tuples, which in turn are composed of
attribute and value components. The relation is the sole data structure
used to represent all information in the database.  Relations as defined
in the relational model are derived from relations in set theory, a branch
of mathematics, and share many of their properties. They are formally
defined in Codd’s 1970 paper.</li>
<li>think of relation as table, tuples as columns</li>
</ul></li>
<li><p>The integrity component</p>

<ul>
<li>The integrity component: This component defines methods that enforce
relationships within and between relations (or tables) in the structural
component.  These methods are called constraints, and are expressed in the
form of rules. There are three principle types of integrity: domain
integrity, governing values in columns; entity integrity, governing rows
in tables; and referential integrity, governing how tables relate to one
another. Integrity has no analog in set theory, but rather is unique to
relational theory. It was initially addressed in Codd’s 1970 paper and
greatly expanded upon in the 1980s by Codd and others.</li>
</ul></li>
<li><p>The manipulative component</p>

<ul>
<li>The manipulative component: This aspect defines the methods with which to
operate on or manipulate information. Like relations, these operations
also have their roots in mathematics. They are formalized in relational
algebra and relational calculus as originally presented in Codd’s 1972
paper “Relational Completeness of Data Base Sublanguages.”</li>
</ul></li>
</ol>
</blockquote>

<h3>SQL and the Relational Model</h3>

<p>lots of information that the author cannot all touch on, yada yada</p>

<h2>The Structural Component</h2>

<p>The first of Codd's rules. </p>

<h3>The Information Principle (Information Rule)</h3>

<blockquote>
  <p>All information in a relational database is represented explicitly at the
logical level and in exactly one way - by values in tables. </p>
</blockquote>

<p>OR in Date's words</p>

<blockquote>
  <p>The entire information content of the database is represented in one and only
one way, namely as explicit values in column positions in rows in tables.</p>
</blockquote>

<h5>Logical Level</h5>

<ul>
<li><p>The view presented in the logical level consists of tables, made up of rows,
which in turn are made up of values.</p></li>
<li><p>The view is completely independent of the database system - the technology
(software or hardware) that enables it.</p></li>
</ul>

<h5>Physical Level (Physical Representation)</h5>

<ul>
<li>The technology of the system</li>
</ul>

<h3>The Sanctity of the Logical Level</h3>

<p>Codd:</p>

<blockquote>
  <ol>
<li><p><em>Physical Data Independence</em> The logical view can in no way be impaired by the
underlying software or hardware.</p></li>
<li><p><em>Logical Data Independence</em> Application programs and terminal
activities remain logically unimpaired when information-preserving changes of
any kind that theoretically permit un-impairment are made to the base tables.</p></li>
<li><p><em>Distribution Independence</em> Even if the database is spread across
various locations, it cannot impact the logical view of data.</p></li>
<li><p><em>Nonsubversion Rule</em> The database software may not provide any
facility which can subvert the integrity constraints of the logical view.</p></li>
</ol>
</blockquote>

<p>table = relation (variables)
rows = tuples
columns = values
types = domains</p>

<p><em>Tables are not the same thing as relations</em></p>

<h3>Tuples</h3>

<p>A set of values each of which has an associated attribute.  An attribute defines
the values name and domain.  The combination of an attribute and a value is
called a component.</p>

<p>Figure 3-2</p>

<h3>Relations</h3>

<p>Is a set of one or more tuples that share the same heading.</p>

<p>Think of an array of C structs.</p>

<h5>Degree and Cardinality</h5>

<p>Degree => width
Cardinality => height</p>

<h5>Mathematical Relations</h5>

<p>Cross product or Cartesian product
    - a combination of every value in every domain with every value in every
      other domain.</p>

<p>The cross product of the columns is the total set of all tuples for a relation</p>

<h5>Relational Relations</h5>

<p>Order in a relational tuple does not matter because all tuple attributes have
names to identify them where this is not the case in mathematics.</p>

<p>Codd:</p>

<blockquote>
  <p>Moreover, the (relational) approach has a close tie to first-order predicate
logic—a logic on which most of mathematics is based, hence a logic which can
be expected to have strength, endurance, and many applications.</p>
</blockquote>

<h3>Tables: Relation Variables</h3>

<blockquote>
  <p>A relation, though it contains values, is itself just a value, just like an
integer or a string. The value of a relation is given by the particular set of
tuples it contains. Likewise, the value of each tuple in turn is given by the
specific values within it. Thus, the value of a relation is determined by the
sum of its parts. Figure 3-5 illustrates this. It depicts three relations,
represented by R1, R2, and R3, taken over I×F. Each represents a different
value, or relation.  R1, R2, and R3 are not relations but rather relation
variables. They represent relations.  Codd referred to them as named
relations. Date (2003) calls them relvars. SQL calls them tables.  They are
also known as base tables. The bottom line is that they are simply variables
whose values are relations. I will simply refer to them here as tables, as
that is what you will be dealing with in SQL.</p>
</blockquote>

<p>Figure 3-5</p>

<p>A relation is a value, a table is a variable to which relations are assigned.</p>

<blockquote>
  <p>Tables, like variables, have both a name and a value.  Their name is just a
symbol. Their value is a relation. They are no different than variables in
algebra, such as x and y in the equation of a line. Tables share all the
properties of relations (heading, degree, cardinality, etc.) just as integer
variables share the properties of integers.</p>
</blockquote>

<p>SQL update on a table produces a new relation!!</p>

<h4>Views: Virtual Tables</h4>

<p><em>Views are relational expressions that yield relations</em></p>

<p>Codd:</p>

<blockquote>
  <p>A view is a virtual relation (table) defined by means of an expression or
sequence of commands. Although not directly supported by actual data, a view
appears to a user as if were an additional base table kept up-to-date and in
the state of integrity with other base tables. Views are useful for permitting
application programs and users at terminals to interact with constant view
structures, even when the base tables themselves are under- going structural
changes at the logical level...</p>
</blockquote>

<h5>Logical Data Independence</h5>

<p>Codd:</p>

<blockquote>
  <ol>
<li>Logical Data Independence. Application programs and terminal activities
remain logically unimpaired when information-preserving changes of any kind
that theoretically permit un-impairment are made to the base tables.</li>
</ol>
</blockquote>

<p>Am example is when a relation is decomposed into two relations for the sake of
normalization.</p>

<h5>Update-able Views</h5>

<blockquote>
  <ol>
<li>View Updating Rule. All views that are theoretically update-able are also
update-able by the system.</li>
</ol>
</blockquote>

<p>i.e. changes to a view should be able to be mapped to the logical layer.  Should
because it is pretty difficult to design</p>

<h3>The System Catalog</h3>

<blockquote>
  <ol>
<li>Dynamic On-Line Catalog Based on the Relational Model. The data base
description is represented at the logical level in the same way as ordinary
data, so that authorized users can apply the same relational language to
its interrogation as they apply to the regular data.</li>
</ol>
</blockquote>

<p>Information about the information a database holds.</p>

<h2>The Integrity Component</h2>

<p><em>Holy shit</em> I am only <em>this</em> far?!</p>

<h3>Primary Keys</h3>

<blockquote>
  <ol>
<li>Guaranteed Access Rule. Each and every datum (atomic value) in a relational
data base is guaranteed to be logically accessible by resorting to a
combination of table name, primary key value and column name.</li>
</ol>
</blockquote>

<p>The primary key is the set of attributes in a relation that uniquely identifies
each tuple within it.</p>

<blockquote>
  <p>1.The value (or combined values) of that attribute (or attributes) is unique
for every tuple in the relation.  </p>

<p>2.If the key is composed of more than one attribute, all of the attributes
that define the key must be necessary to ensure uniqueness. That is, every
attribute in the key is sufficient to ensure uniqueness, but also necessary as
well—if one were absent, then the uniqueness condition would not hold.</p>
</blockquote>

<p>If both 1 and 2 are met then the resulting attribute or group of attributes is a
key ( or candidate key).</p>

<p>If condition 1 is met but not condition 2, then the attribute (or group ) is
called a superkey. ( a key that could stand to lose some weight)</p>

<h3>Foreign Keys</h3>

<p>foreign key relationship
- a keys identification property allows a tuple in one relation to identify (or
  reference) a specific tuple in another relation by way of a common key value.</p>

<p>Figure 3-6</p>

<h3>Constraints</h3>

<p>They enforce database rules and relationships and preserve order in general.
four general classes of integrity:</p>

<blockquote>
  <ul>
<li><p>Domain integrity: Domain integrity is the relationship between attribute
values and their associated domains. In the relational model, domain integrity
is instituted through domain constraints. A domain constraint requires that each
attribute value in a tuple exist within its associated domain. For example, if
the type<em>id attribute in the foods table is declared as an integer, then the
corresponding values of type</em>id in all tuples in the foods table must be integer
values—not floating-point numbers or strings. Domain integrity is also referred
to as attribute integrity—it pertains to the attributes of a relation. Domain
integrity is not limited to just checking that a given value resides in a given
domain.  It includes additional constraints as well, such as CHECK constraints.
CHECK constraints (which are covered in Chapter 4) can define arbitrarily
complex rules on what constitutes a permissible value for a given attribute.</p></li>
<li><p>Entity integrity: This form of integrity is mandated by the Guaranteed Access
Rule: each tuple in a relation must be uniquely identifiable. Whereas domain
integrity is concerned with a relation’s attribute values, entity integrity is
concerned with its tuples. The term "entity" here is a rather loose term for
table. It originates from database modeling (i.e., entity-relationship
diagrams). In this particular context, an entity simply refers to anything in
the real world that must be represented in a database.</p></li>
<li><p>Referential integrity: This form of integrity pertains to relationships between
tables, specifically the preservation of foreign key relationships. Whereas
entity integrity pertains to tuples in a relation, referential integrity
pertains to tuples between relations.</p></li>
<li><p>User-defined integrity: User-defined integrity encompasses any form of
integrity not defined in the other forms. Many relational databases offer
various facilities that go beyond the normal constraint mechanisms. One such
example is triggers, which are covered in Chapter 4.</p></li>
</ul>
</blockquote>

<p>Codd:</p>

<blockquote>
  <ol>
<li>Integrity Independence. Integrity constraints specific to a particular
relational data base must be definable in the relational data sub-language
and storable in the catalog, not in the application programs.</li>
</ol>
</blockquote>

<h3>Null values</h3>

<p>Codd:</p>

<blockquote>
  <ol>
<li>Systematic Treatment of Null Values. Null values (distinct from the empty
character string or a string of blank characters and distinct from zero or
any other number) are supported in fully relational DBMS for representing
missing information and inapplicable information in a systematic way,
independent of data type.</li>
</ol>

<p>In this case, the null value doesn't necessarily mean “unknown” but rather
“not applicable.” Thus, a value may be null because it is either missing (a
value exists but was not input) or uncertain (it is not known whether a value
exists at all), or it is simply not applicable for the tuple (or employee) in
question.</p>

<p>Date, Codd’s colleague and well-known authority on the relational model, is
opposed to them:</p>

<blockquote>
  <p>...we should make it very clear that in our opinion (and in that of many
other writers too, we hasten to add), nulls and 3VL are a serious mistake
and have no place in a clean formal system like the relational model.</p>
</blockquote>

<p></blockquote></p>
